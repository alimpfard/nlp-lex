# toplevel syntax
#   constant  :- symbol :- string-literal
#   rule      :- symbol :: defn
#   normalise :- char <= char-list (comma separated? ask for ideas)
#   stopwords :- stopword quoted-string-literal (commas optional)
#   option    :- option _name_ _value_
#   -"string" subst with file content
#
# split with a default delimiter?
# NFA output + decompile back
#
# --

option lemmatise on

u0ffe  :- "\u0ffe"
number :: \d+
float  :: {{number}}\.{{number}}
word   :: [\w{{u0ffe}}]+

t      <= cdf
x      <= xyz

stopword "test", "shit", "blah", -"stopwords.list"

# TODO items
# - optimise regexp itself
#   - if all branches of an Alternative are literals, transform to character class { 1|2|3|4|5|6... -> [123456] }
#
# - subpatterns should be preserved and tagged (for later referencing)
#   - consequently, allow `(?:)' expressions
#
# - Codegen
#   implement library functions __nlex_*
#
# - testing the lexer live?
